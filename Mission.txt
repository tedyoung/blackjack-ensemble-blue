MISSION PLANS
-------------

CURRENTLY:
==========

High-level Scenario:
    A. Select which PlayerAccounts will enter and play the game
    B. Those PlayerAccounts are passed into Game's constructor -- we don't hold reference to PlayerAccount, only its ID (and Name)
    C. Playing the Game from here on is the same, until the Game is over
    D. When Game is over, add bet payout to PlayerAccount's balance, by using the Player IDs from the Game

    ----- player management (admin) -----
    1. Show player creation form: name, starting balance
    2. Create player
    3. Show list of players

    ----- player account -----
    * ID
    * View balance
    * Deposit
    * Withdraw
    * Games played and the results
    * Change name

    ----- starting a new game -----
    1. Choose from existing players, which ones will participate: show all players, checkbox for selection
        * Must have some minimum balance to join game (add this filter later)
    2. Each player places bet
        * One form that collects bets for all players
    3. Initial deal
    4. play game
    5. payout to player
    6. show results

    -----

## Event-Sourced PlayerAccount aggregate:

[ ] Create PlayerAccount that holds global PlayerId, Name, and Balance

    [X] Extract Event handling code from PlayerAccount into a separate base class
        [X] Split the _adding_ of events to the List (handle in the base class) from the _applying_
            of the events to the state (handled in the concrete subclass)

    [X] PlayerRegistered event needs the player's name

    [X] Create MoneyBet event
        [X] reduces balance by bet amount

    [X] Game-specific events
        [X] PlayerWonGame (with Payout amount and reason)
        [X] PlayerLostGame (reason)


    [ ] Store them in a PlayerAccountRepository (in-memory, to start)
        [ ] Created at startup
        [X] In-memory Repository should be able to:
            [X] Assign an ID for a "new" PlayerAccount (when ID is null)
            [X] Not assign an ID if already exists
            [X] Can load a saved PlayerAccount with all its state
            [X] Assign unique IDs for multiple "new" PlayerAccounts
            [X] Store the events and not the actual PlayerAccount internal state
                and rebuild the object from the stored events
            [X] Store events as JSON plus composite key instead of PlayerAccountEvent objects
                [X] Create event DTO as a class that stores the Player ID, Event ID, Event Type, and the contents of an Event as JSON
                [X] REFACTOR the PlayerAccountRepository so that it stores EventDto objects instead of PlayerAccountEvents
                    [X] Implement transformation of PlayerAccountEvent objects to EventDto (required for the next step)
                        [X] Refactor repository save() method:
                            PlayerAccountEvents gets transformed to eventDto's which are stored in the eventsByPlayer map
                    [X] Implement transformation of EventDto objects back into PlayerAccountEvent objects (required by the next step)
                        [X] Refactor repository find() method:
                            eventDto's get transformed into PlayerAccountEvents which are used to rebuild the PlayerAccount

        See PlayerAccount comments (line 9, 19-20) and the failing
        PlayerAccountTest#registeringPlayerEmitsPlayerRegistered()

            [X] Where to store (and generate) the Event ID (as part of the EventDto/Table schema)? (Relates to the AtomicInteger being used in PlayerAccountRepository)
            [X] Store only NEW events since the PlayerAccount was last loaded (currently we load/save the entire list of events)

                [X] Change behavior to: only store new event(s) upon save to PlayerAccount Repo.

                [X] PlayerAccount creation via factory method
                [X] PlayerAccountRepository should ask EventSourcedAggregate for the
                    latest event ID when assigning event IDs in the #save() method.
                [X] Aggregate only needs to hold NEW events, not ALL events: remove `events` field
                [X] EventSourceAggregate must keep track of the "last" (most recent) event ID loaded during reconstitution

                Scenario 1 - new PlayerAccount:
                    given:
                        PlayerAccount account = PlayerAccount.register("dontcare")
                    then:
                        lastEventId == 0

                Scenario 1.5
                    given:
                        account.bet()
                    then:
                        lastEventId == 0

TODO we think it works, but want to double-check next time
                Scenario 2
                    given:
                        repository.save(account)
                    when:
                        var loadedAccount = repository.find(42)
                    then:
                        loadedAccount.lastEventId() == 1

                Scenario 3
                    given:
                        loadedAccount.lose(event1) // will have id of 2
                        loadedAccount.bet(event2)  // will have id of 3
                        loadedAccount.lastEventId() == 1
                    when:
                        repository.save(account)
                    then:
                        var loadedAccount = repository.find(42)
                        loadedAccount.lastEventId() == 3

==> WE ARE HERE:
    [ ] clean up commented out code in BlackjackControllerTest
    [ ] Make hashCode "correct" for the case when playerId is null

    [ ] Welcome screen work:
        [ ] Show all PlayerAccounts: Names + Player IDs with checkboxes

        [ ] Send in the Player IDs who are selected (checkbox checked)
        [ ] Add Player Name to the PlayerInGame object
        [ ] Pass in player name along with player ID to the createGame from GameService

        [ ] Create a Read model for PlayerId plus Name for selecting who participates in the game from the initial page


    [ ] Check lastEventId upon write: must be the same as the lastEventId in the database
        for concurrency

Event-handling:
    Goal is to be able to handle a sequence of events, e.g.:

    [opened account] -> PlayerRegistered event
    MoneyDeposited event: 100
        balance = 100
    MoneyBet event: 10
        balance = 90

    [lost game] -> PlayerLostGame event (granular event, not generic PlayerGameOutcome)

    MoneyBet: 10
        balance = 80

    [won blackjack] -> PlayerWonBlackjack event
    MoneyWon: 25
        balance = 105



        class PlayerAccount
              private PlayerId playerId
              private List<PlayerAccountEvent> events
              private int balance; // not persisted

              PlayerAccount(PlayerId playerId) {
                this.playerId = playerId;
                this.events = new ArrayList<>();


              PlayerAccount(PlayerId playerId,  List<PlayerAccountEvent> events) {
                for each event, apply(event)
              }

              public void deposit(int amount) {
                 event = new MoneyDeposited(amount)
                 events.add(event);
                 apply(event)
              }

              public void bet(int amount) {
                event = new MoneyBet(amount)
                events.add(event);
                apply(event);
              }

              public void bet(int amount) {
                events.add(new MoneyBet(amount));
              }

              public int balance() {
                return balance;
              }

              public void apply(MoneyDeposited event) {

              }
        }

        abstract PlayerAccountEvent
              private PlayerId playerId

        class PlayerNameChanged extends PlayerAccountEvent {
            String name;
        }

        class MoneyDeposited extends PlayerAccountEvent {
            int depositAmount;
        }

        class MoneyBet extends .. {
            int betAmount;
        }

        class MoneyWon extends .. {
            int winAmount;
        }

        [X] All events should be Records
            [X] Convert MoneyDeposited to record
        [X] Initialization event - PlayerRegistered
            [X] Create PlayerRegistered event
            [X] change constructor to take a list of generic events (abstract or interface)
        [ ] Create a bunch of PlayerAccount objects
            [ ] Player starts with balance of $100

    [ ] PlayerAccount can tell us how many games they've won and lost

    [ ] Add "Name" to PlayerDoneEvent for viewing instead of ID
    [ ] PlayerAccount will be referenced by its ID (requires repository)
    [ ] Bets can not exceed player balance
    [ ] Cash out process
    [ ] Player Management
        [ ] Create Player object that persists across games
    [ ] (Optional) Rename tests in GameTest to use the same pattern throughout
    [ ] GameBuilder: consider addPlayer() method for when we need a player, but don't care about its ID (or bet)
    [ ] Game#placePlayerBets(), etc. is a bit confusing, and playersInGame has Primitive Obsession smell

    [X] Change all usages of new PlayerId() to PlayerId.of()
    [X] GameService: create new method: createGame(List<PlayerId> playerIds)
        [X] Start TDDing against GameService
            [X] Replace createGame(int numberOfPlayers) with createGame(List<PlayerId)
            [X] Same for createGame(int numberOfPlayers, Shoe shoe)
    [X] Modify create-game endpoint to accept NewGameForm with Player IDs to join the game
    [X] GameBuilder: Can we remove placeBets boolean field and just look at size of playerBets list?

    [ ] in NewGameForm, validate (ensure it's an Integer), translate List<String> -> List<PlayerId>

[ ] Create Player Aggregate - we want players to play multiple games
    [X] Move player creation out of Game's constructor into GameService(?)
    [X] Rename Player to PlayerInGame
    [X] Game is responsible for creating PlayerInGame
    [X] Game constructor should accept a list of PlayerAccount IDs
    [X] GameService calls new constructor that takes Player IDs
    [X] Place Bets need to have each Bet associated with its Player ID
        [X] Need new value object (PlayerBet) representing the Bet for a specific Player ID
        [X] Update placeBets and currentBets to use the PlayerBet object
        [X] GameFactory#createBets is incomplete (generalizing createThreeBets() method)
        [X] Replace usage of Game#placeBets() with Game#placePlayerBets in GameTest
        [X] GameTest#gameRemembersBetsPlaced is an incomplete test: PlayerInGame needs to have its ID match the incoming Player ID (make sure to use `PlayerId` instead of `int`)
    [X] GameFactory: line 70: migrating line 64 to use Player IDs
        [X] Replace usage of deprecated Game(shoe, playerCount) constructor and
    [X] FIXMEs:
        [X] GameFactory:81 // done: should not use deprecated placeBets()
        [X] GameFactory:88 // done: don't use hard-coded playerId
    [X] Remove Game constructor: Game(Shoe shoe, PlayerCount playerCount)
    [X] Tidy up after removals
    [X] Transform GameFactory to a GameBuilder to deal with various combinations
        [X] Continue to generalize based on addPlayer(with a player ID as param)
            GameFactory:26
    [X] Refactor Game#placePlayerBets()
    [ ] Stop using GameService.placeBets(List<Bet>), replace with using List<PlayerBet>

NEXT:
=====


[ ] Blackjack Table (where players enter to sit and play/leave when they're done)

[ ] Persist all games using Event Sourcing - requires some design discussion as well as separate aggregates already persisted



# IDEAS

[ ] Replace Mockito Spy usage with an Output Tracker for GameMonitor tests (and elsewhere?)

[ ] Remove duplicate methods in GameFactory

[ ] Next game prompt

[ ] Handle rounding for Blackjack


DESIGN:
------

[ ] Define explicit states for the Game:
        Created with # Players (awaiting bets)
        Bets Placed
        Initial Deal Completed (right after bets placed)
        Player(s) Turn
        Dealer's Turn
        Pay-off bets based on outcome (Game is over)
    First as an enum, then look at the State Pattern to enforce preconditions


TIDYING:
-------

[ ] Clean up BlackjackControllerTest, e.g., "placeBetsPageRedirectsToGame" how do we feel about this test?

[ ] Clean up GameTest (still mentions deckFactory, a bit noisy, etc.)


LATER:
======

    [ ] Extract Deck interface with draw method.
        [ ] Maybe later add isEmpty to replace size == 0
        [ ] Rename size() to be remainingCardCount()

    [ ] Handle cases for Player (and Dealer) hits
            check on these, are we done here:
        [ ] GameService can use isGameOver() to know when to notify Ports
            -- Do we need new tests or modify Repository/GameMonitor tests for Game Over situations:
                1. initial deal with Blackjack
                2. player hits and goes bust
                3. player stands

        [ ] Need to move mapping of Enum to String out of the domain (including StubDeck)

        [ ] GameService.currentGame() perhaps should only return a read-only view to prevent commands from being directly executed against Game (and entity) from places like the BlackjackController?

(Update diagram to show what it "should" look like)

    [ ] {FEATURE}
        Multiple (more than one) decks mixed together

    [ ] {TEST REFACTOR}
        Replace direct StubDeck and StubDeckFactory (single and multiplayer) with StubDeckBuilder
        (ongoing/as needed)

    [ ] {TEST REFACTOR}
        Create GameBuilder (Test Data Builder) to combine with StubDeckBuilder to specify the number of players
        that is validated across both Deck and Game

    [ ] {UI FEATURE}
        Use Card images instead of text

## Stub Deck support

    [ ] Test Data Builder for building decks: [mostly done]
                StubDeckBuilder.playerCountOf(3)
                    .addPlayerDealtBlackjack()                  // player 1
                    .addPlayerHitsOnceAndDoesNotBustAndStands() // player 2
                    .addPlayerHitsAndGoesBust()                 // player 3
                    .withDealerHitsOnTheirTurn()                // dealer
                    .build();

    [ ] Different default Dealer hands

## Multiple Players

    [ ] Multiple players, one "screen" (not multiple players each with their own screen), each player taking their turn sequentially

        [ ] BUG: Double-stand-button-click! Use synchronization token to fix.

        [ ] (Maybe? Non-trivial) UI: Add "confirm" button after player's turn is over before moving to next player

        [ ] UI: Add button to Start New Game after game is over

        [ ] Get rid of these in Multi-player situation?

            [ ] Determine outcome for multiplayer
                public PlayerOutcome determineOutcome() {

            [ ] Value of multiplayer hands
                public int playerHandValue() {

            [ ] Hands for multiplayer
                public List<Card> playerCards() {
                and deal with usage in GameView class


        [ ] Non-recursive approach for playerStateChanged() implementation? "Argue" (spike) in Code Refactoring

            Two directions for this experiment:

            1. Having uncompletedPlayer + completedPlayers:

                private final List<Player> uncompletedPlayers; // activePlayers
                                                               // playersWhoHaveNotTakenTheirTurnYet;
                                                               // uncompletedPlayers

                private final List<Player> completedPlayers;

            2. Having granular lists:
                private List<Player> originalPlayers;

                private final List<Player> standingPlayers;
                private final List<Player> blackjackPlayers; // completed
                private final List<Player> bustedPlayers;    // completed

        [ ] Segregate Single vs. Multi-player tests for DealerTurn?

        [ ] Missing abstraction for the Dealer (i.e., a class)
            Trigger: detect if the dealer took their turn

        [ ] Make test methods consistent

            [ ] (Cleanup) Drop "given" in front of test names

            [ ] Visibility: public and throws Exception (share live template?)

          [ ] Inline setup in CsvGameRepositoryTest:29 and 42, to make each test method readable in ISOLATION

          [ ] UI: show what happened to the player that is now done above the Dealer's hand

          [ ] Maybe: move "game state" to be an Enum instead of a boolean query

          [ ] UI: show the hand's "value" in the Web layout

          [ ] Exception for "hit" when Player doesn't have 2 cards (i.e., must have 2 or more)


      [ ] Consider replacing growing number of Game constructors with a test builder?

      [ ] StubDeck is not meant for use at the PLAYER object level (see PlayerDoneTest), create alternate?

      [ ] Shift language from game-oriented to player-oriented

          [ ] Language of PlayerOutcome Enum?



FUTURE TASKS:

    [?] (Bug) Add missing test around dealer turn behavior: the dealer must _not_ take its turn if all players go bust.

    [ ] Player joins Game and provides name, which must not have started, starts when someone pushes the "start" button

    [X] (Bug) Web UI doesn't pay attention to initial deal of Blackjack -- game should be over


COMPLETED TASKS
===============
[X] Make sure player IDs are all using value object (PlayerId) instead of int
    [X] See Game#currentPlayerId()
    [X] See PlayerResult#id field: should be of type `PlayerId` not `int`
    [X] Clean up assertions that use .id() instead of comparing against `PlayerId`
    [X] Convert PlayerDoneEvent to use PlayerId


[X] Replace GameService.placeBets(List<Bet>) with List<PlayerBet> as parameter
[X] BettingForm needs to associate playerIds with their individual bets

[X] Use request parameter to placeBets as our Feature Flag to turn on new player bet form
    otherwise default to using just bettingForm.getBets()
    [X] Get all tests to pass (again) by using placeBets()
    [X] Add the "feature flag" parameter back (uncomment)
    [X] Get the placeBets to work with feature flag turned ON with tests
    [X] Expose playerIds in the game
    [X] Re-enable disabled test: BlackjackControllerTest#bettingFormHasPlayerIdsFromCreatedGame
    [X] BettingForm.getPlayerBets() needs to transform from the Map not the Lists
    [X] Update the HTML form to use the flag

    -- at this point we remove the feature flag --
    [X] Remove deprecated placeBets() and the feature flag
    [X] Remove deprecated elements from BettingForm


[X] Move PlayerDoneEvent creation into Player: Remove `List<PlayerDoneEvent> events` from Game
    [X] Don't bother recording the event in Game, Player has this info: ask Player to record the event
        [X] Player: add query for its PlayerDoneEvent (Test-drive this)
        [X] PlayerDoneEvent could be a Record
    [X] Change Game#events() to iterate over all DONE players and accumulate PlayerDoneEvents


[X] Consolidate (encapsulate) Bet  into Player
    [X] Move Bet into Player
    [X] Expand betsHaveBeenPlaced into an Enum
    [X] Complete transition to using GameState enum (see Game#isGameOver)
    [X] Review naming of GameState enums: still make sense?


[X] Back-fill tests for Player (can't hit when busted, or when stood)
    [X] Tests for requireNotDone()
    [X] Change IllegalArgumentException to be more Domain-specific


[X] Add precondition that bets must have been placed before Initial Deal
    [X] throw exception if bets not placed in initial deal
    [X] fix up all the tests we broke due to the above

[X] When game is over, with the outcome, show their bet Payout (lost, won $$, or push)
    [X] Calculate Payout

    [X] Example: Standard win payoff of 2:1
        1 Player
        BETS 10
        BEATS the dealer by Standing (not Blackjack)
        Player gets PAYOUT of 20

    [X] Example: Standard PUSH payoff of 1:1
        1 Player
        BETS 17
        PUSHES the dealer by Standing (tie)
        Player gets PAYOUT of 17

    [X] Example: Blackjack payoff of 3:2
        1 Player
        BETS 20
        BEATS the dealer by being dealt Blackjack
        Player gets PAYOUT of 50 (= 2.5 * 20)

    Example: 2 Players
        Player 1 BETS 12
        Player 2 BETS 27


[X] Betting Feature
    [X] Accept a form containing the bet for each player (a List of integers as "dollars")
    [X] Create Thymeleaf page that asks for bets from each player (using a single form)
    [X] Obtain bets from each player
        - index page submits # of players to place bets page
        - place bets page know how many players there are,
          asks for bet amount all players in single form
        - done page would show result and total balance
        - Bet size any integer $1->$100

[X] Validation: PlayerCount (aka number of players) should be between 1 and 5
    [X] Basic validation
    [X] Convert to use static `of()` instead of `new PlayerCount`

[X] Validation: Don't allow any bets to be zero, or negative
    And Max of 100

[X] Fix primitive obsession for individual bets
    [X] Make change internally
    [X] Change public usage (placeBets/currentBets) to use List<Bet>

[X] Object Protocol validation
    [X] Must not allow placeBets to be called if bets have already been placed

[X] Precondition: Bets must be placed before initial deal and any player action (hit, stand)
    [X] Throws exception
    [X] Throws Domain-specific exception

[X] Validation: Require number of bets in list of bet amounts to match number of players

[X] Refactor placeBets() and push into Game
    [X] Tidy up GameTest


[X] {BUG}
    Deck runs out of cards when playing multiple games

    ❌  1. Deck is a never-ending stream of cards: Deck is responsible for
           tracking discarded cards and putting them back into the draw stream
           when it runs out. Never have duplicate Cards.

    ✅  2. Deck runs out of cards (can ask isEmpty?) and when the Deck is empty,
           call some "DeckFactory" to get a new Deck of cards and throw away the
           old Deck. Will observe duplicate Cards: decks are mixed.

    [X] DeckFactory does not actually create a new Deck when using the default
        and (Deck) constructors: returns the same deck (which would already be used)

    [X] ShuffledDeck violates Hex Arch (accesses hardware/random number generator)
        (The violation is the SHUFFLING, not the deck itself)
        [X] Need a Test Double (Stub) for Shuffler implementation for GameServiceTest
            Update constructors on GameService to take in a Shuffler implementation
        [X] Create concrete implementation of Shuffler using Collections.shuffle()

        [X] Shoe is "N" shuffled Decks (production = 4 decks) [Later: shuffle all 208 cards]
            [X] A new Shoe is provided when a new Game starts (this way we never run out of cards)
            [X] A deck is shuffled by passing in 52 random numbers from an external Port implementation

        [X] Remove Shoe from GameService.createForTest method, and tests should use the createGame method that takes a shoe
        [X] GameService should no longer have a field for Shoe,
            it will create a new one for each new Game
        [X] Goal: get rid of DeckFactory and DeckProvider


    [X] Explore if GameService can work just with Shoe instead of DeckFactory
        [X] Replace DeckFactory with Shoe in constructor/field

    [X] Explore getting rid of size() method on Shoe
        [X] Does Shoe need to implement the Deck interface? Probably not?
        [X] Deck needs to be an interface because of random (shuffled) implementation

    [X] Back-fill tests for Shoe
        [X] Push GameDeckFactory tests closer to Game

    [X] Replace implementation of Deck with Shoe.

    [X] Multiple players for the one ongoing game - DOMAIN


    [X] Fixing up tests to check for game.isGameOver()
        -- gathering tests together: do we need more coverage for isGameOver()?

    [X] {REFACTOR}
        Split domain into domain vs. application -- abide by Hex Arch
            Service and elsewhere?

        [X] Fix violations: Add ArchUnit test for checking Hex Arch violations


    [X] Create AssertJ assertion for DealerHand and "Hole" Card (see GameCardFaceTest)
        Exploration complete.

    [X] Could go further with custom assertions, e.g., in GameCardFaceTest replace
            assertThat(game.currentPlayerCards().get(0))
                    .isFaceUp();
            assertThat(game.currentPlayerCards().get(1))
                    .isFaceUp();

           (as well as the Dealer all-cards-face-up scenario)

        with:

            assertThat(game)
                    .currentPlayerHand()
                    .allCardsFaceUp();

    [X] BUG: All Player(s) initially dealt blackjack (including a single player dealt Blackjack),
        game should be over, but player presented with HIT and STAND buttons. Should redirect to "game over" page.
        CustomDeck to recreate bug: A,K,Q,7
        Also, check multiplayer if all players have Blackjack
            2 player: A,A,K,Q,K,7
        "subcutaneous" (under the skin) test

    [X] Game over and Dealer XX card not shown when all players (single or multi-player) are dealt blackjack

    [X] Feature: Create a stub deck for playing the actual game
       [X] Finish cleaning up BlackjackControllerTest, replacing StubDeck with the String version (customDeck)
       [X] refactor and clean up of BlackjackController, CustomDeckParser, etc.

    [X] If all players dealt Blackjack, Dealer does not take their turn if Dealer does not have Blackjack
        Explore why we thought this should fail, but it passes (see GameWithBlackjackTest) --hint--> what are "standing" players?

    [X] Convert to Enums for Player Done reason event

        [X] Create display strings for UI with player ID (map from Enum, once we have Player Done Reason enum)

    [X] Non-implemented rule: if Dealer dealt Blackjack, game is over

        [X] Scenario 1:
        - Given a game with two players
          And the first player has blackjack
          And the second player has any cards
          When the dealer draws a third card that adds up to 21
          Then the game result for the first player should be player wins with BLACKJACK

        [X] Scenario 2:
        - Given a game with two players
          And busted not push. When player and dealer have cards valued at 23.
        - Two players. First player stands so that dealer draws a third card.

    [X] ARGHH: Force Game() constructor to specify number of players

    [X] BUG: hide the Dealer's "hole" (hidden) card at the DOMAIN level
        Goal: While Game is In Progress -> Second Card is hidden, show "XX" instead

        * Try out using a Decorator for Card to represent Face Up property? Tried, didn't like

          * "unflip" the Dealer's second card (hole card) so it's Face Up (visible) after the game is over (after they took their turn)
            Currently try to figure out how to flip the card over: get the undecorated card, or add a "flip()" method to the decorator

          * The Adapter test (gameIsOverThenHasDealerCards) is failing and will get fixed when we fix the domain test that's failing

        * Rename GameOutcomeTest to GameOverTest

        Option 0: Card knows whether face up or face down (immutable version)

        [X] Option 1: Card knows whether face up or face down
            Pros
                least invasive approach
                most closely simulates the real world (which is different from
                modelling sufficiently the real world)
            Cons
                every card will have an attribute that most will not use/need
                would make card no longer a Value Object (mutable)
                would require a change in the mapper

        Option 2: Special card that is face down (subclass Card)
            Pros
                no change to the adapter, including mappers
                Card remains immutable
            Cons
                requires a special Suit and Rank to represent hidden

        Option 3: Dealer specific Hand subclass
            Pros
                Only the dealer hand cares about FaceUp/FaceDown
                Fixes other issues regarding dealer specific Hand behavior
                (see ConsoleHand.java line 13)
                Subclass would only be adding behavior (pushing down dealer
                 specific)
            Cons
                Can't handle all Hands generically

      [X] When we're out of players, then the game is over and show final game state for all players


    [X] Show all events for all previous players (e.g., they hit and went busted)

    [X] Refactor/clean up of PlayerOutcomeView -- stop storing player & dealerHand as fields pre-calculate in of() method

    [X] Clean up duplication between Game view and PlayerOutcomeView

    [X] Cleanup of PlayerOutcomeViewTest

    [X] Handle view of multiple players:

        [X] Thymeleaf Template of the GameOutcomeView & BlackjackController

        [X] Create VIEW for multiple players to be shown when the game is over
            Change BlackjackController.viewDone() to use the new GameOutcomeView DTO

    [X] GameOutcomeView driven via GameOutcomeViewTest
        NEXT: Drive converting Dealer Hand to list of strings (we have a failing test as a breadcrumb)

    [X] Complete Game.players() which returns PlayerResult value objects for each player, to eventually remove the getPlayers() method.

        [X] Start micro-testing ("directly against") PlayerResult

        [X] Look at potentially cleaning up GameTest tests that look at JUST the PlayerOutcome and not the entire PlayerResult

    [X] Rename addPlayerEvent -> addCurrentPlayerToEvents ?

    [X] Refactor: put condition line 104 into dealerTurn() itself


    [X] Generate events upon Player state change (reason for player becoming "done")

         [X] Add to DealerTurnTest at the end: single player goes bust THEN dealer does NOT take their turn
                  Multi-player variations as well
                  RULE: Dealer takes their turn when at least one player is STANDING

         [X] New method: haveStandingPlayers
                "standing players " (via playerStands) == don't know if they won or not until Dealer goes.
                (vs. Blackjack == "outcome known" as they've already won)
                (vs. Bust == "outcome known" as they've already lost)


        [X] Need additional tests for: if NOT all players have Blackjack, then Dealer MUST take their turn
              RULE: only if ALL players have Blackjack then Dealer MUST NOT take their turn

        [X] Add Tests: if first player has Blackjack, should move to 2nd player
              Need more variations to ensure we've got it
              e.g., 1st player HAS Blackjack, 2nd player does NOT

        [X] BUG: Dealer takes their turn after each player stands instead of when the "game" is over
                Want: Dealer takes turn only after ALL players are done (i.e., isGameOver)
                Currently two tests are failing
                See Game line 120 -- attempting to uncomment this causes many more test failures

        [X] Given a transition of Player to DONE, should generate a "player done" String event

        [X] Rename Player#drawFrom -> initialDrawFrom

        [X] Create PlayerEvent Value Object with ReasonDone (String) and PlayerId (int)

        [X] Refactor Game relating to game being over

        [X] Adapter needs "game is done" instead of "player is done" to decide what page to show


[X] UI: Indicate which player we're showing

[X] Display only current player's cards (and Dealer's)

[X] StubDeck is currently SINGLE player focused: rename to SinglePlayerStubDeck. Create another StubDeck for multiple players?

[X] Change behavior from "round" completed (game is over) when the first player is done -> to -> when ALL players are done.
    (There is a failing test for this with respect to initial deal.)

    RULE NOTE: cannot ask for a player's outcome until all players and dealer are done
      i.e., definition of GAME IS DONE/OVER -> all players have completed their turn and dealer has completed its turn
      (does not make sense to ask for outcome until game is done)

    Need to clarify difference between ALL PLAYERS ARE DONE (and the dealer needs to go)
      VS.
        GAME IS OVER (and we can evaluate Outcome)

    [X] Extract boolean expression to query method: if (currentPlayerIndex == players.size()) {

    [X] replace currentPlayerIndex to use an iterator?

    [X] roundCompleted could be better named gameCompleted

[X] Command: move to next player

[X] Refactor single player to be List of just one player, no external behavioral changes

[X] Initial deal to two players

[X] Fix numOfPlayers and numberOfPlayers variables

     [X] Initial deal: detect "current player", which depends on if any player is dealt Blackjack

         [X] Requires us to be able to differentiate players, perhaps by adding their names as Strings (and maybe ID, too)

              [X] Query: who is the current player? -> return Player (law of Demeter?)

              [X] Query: is current player done?

    [X] Create a Player class

    [X] GameView: refactor stringListOf() to be a function to transform List<Card> to List<String>
        (instead of the currently confusing accumulating parameter)

    [X] Finish moving player-related functionality from Game (and elsewhere) into Player class

        [X] In-progress: get rid of Player.getPlayerHand() by:

            [X] Finding and getting rid of Game.playerHand() usages
            [X] Push Game.playerCards() to Player.cards()
            [X] playerHand.value() needs to move to Player class

            [X] Cleanup: make methods public/private as appropriate

    [X] Shift language from game-oriented to player-oriented

        [X] Consider isGameOver vs. isPlayerDone (once there are multiple players)
            [X] requireGameIsOver -> requirePlayerIsDone
            [X] Rename updateGameDoneState() to be updatePlayerDoneState()

        [X] GameOutcome vs PlayerOutcome

            [X] Outcome method belongs to Player

        [X] Move "isPlayerDone" state from the Game class to Player

    [X] Fix Feature Envy of change in "player done" state upon card dealt and player stands

            [X] Game#playerStands() -- move feature envy code to Player

            [X] Game#playerHits() -- move feature envy code to Player

    [X] Tidying up on Player that needs to be done (e.g., inside hit())

        [X] Is implementation of stand() still OK?

        [X] Look at public interface of Player carefully


# Future Features

2. [ ] Betting - UI, insurance/doubling-down/splitting - mostly DOMAIN

3. [ ] Store ongoing game state in database (H2 first) to support simultaneous multiple games - ARCH/TECH

    [ ] Games need IDs

    [ ] Test PostgreSQL using testcontainers.io


## Bug Fixes/Improvements

[ ] Fix Dealer blackjack (not currently detected)

    [ ] If the Dealer is dealt Blackjack, all players lose unless they have Blackjack themselves (in which case it's a push)



[ ] Enforce constraints:

    [ ] Must not be able to draw card into hand if it's busted - throw an IllegalStateException

                [ ] Possible domain language fixes: round? game?
                [ ] Need a Service class
                [ ] Add more tests to HandDto


# Completed

## Stub Deck related

[X] Test actual cards in player and dealer hands instead of the StubDeck
    (see StubDeckBuilderTest.createTwoPlayerAndDealerEachWithFourCards)

[X] Add docs for how the StubDeck is built (its internal structure)

[X] Do additional refactoring for the StubDeckBuilder

[X] A queue for dealer ranks

[X] Flexible player hand -- addPlayerWithRanks(): can provide list of Ranks [REFACTOR TO THIS]

[X] Refactor the 2 literal to a constant

[X] Simplify the 3 player to just be one (to exercise addPlayerHitsAndGoesBust)

[X] Enforce constraint that number of players specified is the number of players actually added

[X] Change build() to be the Dealer hand specification (as the termination of the builder) -- buildWithDealerHand...




[X] Make sure game is over when player is dealt Blackjack

[X] Add constraints -- throw exceptions if try to hit or stand when game is already over

[X] Fix flaky test: BlackjackControllerWiringTest#donePageShowsFinalGameViewWithOutcome

[X] Persist the final state and outcome of a game when it's over

    [X] Where/how to store?

        [X] Write to a file, comma-separated (csv), append-only

            [X] Following Hexagonal architecture

                [X] Create an Port interface for writing
                [X] Test via behavior (spy)

    ----------> [X] Implement file-based storage of Game Outcome:
                    Each line of the file contains (separated by commas)
                    the final hands for the dealer and player
                    (each card is Rank+Suit, and cards are separated
                     by slashes), and the outcome of the round

                    <dealer's hand>,<player's hand>,<description of outcome>

                    For example:

                    A♥/9♥,3♣/5♠/10♠,Player Loses

                [X] GameOutcomeDto -> GameResultDto
                [X] Title case of Enum
                        PLAYER_BUSTED -> Player Busted
                    exception is
                        Blackjack -> Player Wins Blackjack


[X] Constraint: Can only call determineOutcome() if the game is over Throw IllegalStateException


[X] Get rid of deprecated PlayerResult constructor [bug]
    [X] Reproduce with failing test?

[X] Remove recursion in Game#playerStateChanged
    [X] Remove recursion
    [X] Now that the recursion is gone, refactor the method to make it more readable
